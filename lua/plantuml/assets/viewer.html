<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>PlantUML Viewer</title>
  <style>
    :root {
      --bg: #0b0c0e;
      --fg: #d7d7db;
      --muted: #8b8d94;
      --pill-bg: #1a1b1e;
      --ok: #2ea043;
      --warn: #b8821f;
      --err: #be3431;
      --panel: #0f1013;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font: 14px/1.45 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      display: flex;
      flex-direction: column;
    }

    .top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: .5rem .75rem;
      border-bottom: 1px solid #111318;
      background: var(--panel);
    }

    .status-section {
      display: flex;
      align-items: center;
    }

    .filename-section {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      margin: 0 1rem;
      min-width: 0;
    }

    .info-section {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: .25rem;
    }

    .dot {
      width: .5rem;
      height: .5rem;
      border-radius: 999px;
      display: inline-block;
      vertical-align: middle;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: .35rem;
      padding: .15rem .45rem;
      border-radius: 999px;
      background: var(--pill-bg);
      color: var(--muted);
      font-size: .75rem;
      font-weight: 500;
    }

    .pill .dot {
      background: var(--warn);
    }

    .pill.ok .dot {
      background: var(--ok);
    }

    .pill.err .dot {
      background: var(--err);
    }

    .pill.warn .dot {
      background: var(--warn);
    }

    .file,
    .server-link,
    .timestamp {
      white-space: nowrap;
      overflow: hidden;
    }

    .file {
      color: var(--fg);
      font-weight: 600;
      font-size: 1rem;
      text-align: center;
      max-width: 100%;
    }

    .server-link,
    .timestamp {
      color: var(--muted);
      font-size: .75rem;
      text-overflow: ellipsis;
      text-align: right;
    }

    .server-link {
      text-decoration: none;
      display: block;
    }

    .server-link:hover {
      color: var(--fg);
      text-decoration: underline;
    }

    .wrap {
      flex: 1;
      min-height: 0;
      padding: 0.75rem;
    }

    .board {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      background: #0c0d10;
      outline: 1px solid #111318;
      overflow: hidden;
    }

    #img {
      display: none;
      opacity: 0;
      transition: opacity .2s ease-in-out;
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 100%;
      cursor: pointer;
      user-select: none;
      -webkit-user-drag: none;
    }

    .board.zoom-pan-mode {
      cursor: grab;
    }

    .board.zoom-pan-mode.dragging {
      cursor: grabbing;
    }

    .board.zoom-pan-mode #img {
      max-width: none;
      max-height: none;
      cursor: inherit;
    }

    .board.has-diagram #img {
      display: block;
    }

    #ph {
      color: var(--muted);
      font-size: .9rem;
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="top">
    <div class="status-section">
      <span id="status" class="pill">
        <span class="dot"></span>
        <span id="status-text">connecting</span>
      </span>
    </div>
    <div class="filename-section">
      <span class="file" id="file" title="filename"></span>
    </div>
    <div class="info-section">
      <a class="server-link" id="server-url" href="#" target="_blank" title="PlantUML server URL"></a>
      <span class="timestamp" id="timestamp"></span>
    </div>
  </div>
  <div class="wrap">
    <div class="board" id="board">
      <img id="img" alt="PlantUML diagram">
      <p id="ph">Ready for a diagram.<br>Save a PlantUML file in Neovim to view it here.</p>
    </div>
  </div>
  <script>
    const FALLBACK_WIDTH = 200;
    const MAX_URL_DISPLAY = 70;
    const DOCKER_STATUS_DELAY = 1500;
    const RECONNECT_DELAY = 1000;
    const CLICK_THRESHOLD = 5; // px: distinguish click from drag

    const statusEl = document.getElementById("status");
    const statusText = document.getElementById("status-text");
    const fileEl = document.getElementById("file");
    const ph = document.getElementById("ph");
    const timestampEl = document.getElementById("timestamp");
    const serverUrlEl = document.getElementById("server-url");
    const img = document.getElementById("img");
    const board = document.getElementById("board");

    // State tracking - hasLoadedDiagram only set in img.onload to avoid race
    let hasLoadedDiagram = false;
    let pendingImageLoad = false;
    let dockerStatusTimeoutId = null;
    window.currentFilename = "";

    let isZoomPanMode = false;
    let panX = 0; // pixel offset of image from centered position
    let panY = 0;
    let isDragging = false;
    let dragStartMouseX = 0;
    let dragStartMouseY = 0;
    let dragStartPanX = 0;
    let dragStartPanY = 0;

    function setStatus(kind, text) {
      statusEl.className = 'pill';
      if (kind) statusEl.classList.add(kind);
      statusText.textContent = text;
    }

    function truncateFilename(fullPath, maxWidth) {
      if (!fullPath) return '';
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = getComputedStyle(fileEl).font;

      if (ctx.measureText(fullPath).width <= maxWidth) {
        return fullPath;
      }

      const lastSlashIndex = fullPath.lastIndexOf('/');
      if (lastSlashIndex === -1) {
        return fullPath;
      }

      const filename = fullPath.substring(lastSlashIndex + 1);

      if (ctx.measureText(filename).width > maxWidth) {
        return filename;
      }

      const pathParts = fullPath.split('/');
      let bestResult = filename;

      for (let startIndex = pathParts.length - 2; startIndex >= 1; startIndex--) {
        const remainingParts = pathParts.slice(startIndex);
        const candidate = '...' + '/' + remainingParts.join('/');

        if (ctx.measureText(candidate).width <= maxWidth) {
          bestResult = candidate;
        }
      }

      return bestResult;
    }

    window.truncateFilename = truncateFilename;

    function updateFilenameDisplay() {
      if (window.currentFilename) {
        const filenameSection = document.querySelector('.filename-section');
        let maxWidth = filenameSection.getBoundingClientRect().width - 20;

        if (maxWidth <= 0) {
          maxWidth = Math.max(FALLBACK_WIDTH, window.innerWidth * 0.5);
        }

        const truncatedFilename = truncateFilename(window.currentFilename, maxWidth);
        fileEl.textContent = truncatedFilename;
        fileEl.title = window.currentFilename;
      }
    }

    window.truncateFilename = truncateFilename;
    window.updateFilenameDisplay = updateFilenameDisplay;
    window.addEventListener('resize', () => requestAnimationFrame(updateFilenameDisplay));

    function isImageMinified() {
      if (!img.naturalWidth || !img.naturalHeight) return false;
      const boardRect = board.getBoundingClientRect();
      return img.naturalWidth > boardRect.width || img.naturalHeight > boardRect.height;
    }

    function resetZoomPan() {
      isZoomPanMode = false;
      isDragging = false;
      panX = 0;
      panY = 0;
      board.classList.remove('zoom-pan-mode', 'dragging');
      img.style.transform = '';
    }

    // Enter zoom-pan mode, centering on the click point.
    // clickX/clickY are relative to the board.
    function enterZoomPanMode(clickX, clickY) {
      const boardRect = board.getBoundingClientRect();

      // Current displayed size of the image (fit-to-screen)
      const displayedWidth = img.clientWidth;
      const displayedHeight = img.clientHeight;

      // Where the click falls on the image in natural-pixel coordinates
      // The image is centered in the board by flexbox.
      const imgLeft = (boardRect.width - displayedWidth) / 2;
      const imgTop = (boardRect.height - displayedHeight) / 2;
      const relX = clickX - imgLeft;
      const relY = clickY - imgTop;

      // Fraction of the image that was clicked
      const fracX = relX / displayedWidth;
      const fracY = relY / displayedHeight;

      // In zoom-pan mode the image is at natural size, centered by default (panX=panY=0).
      // We want the point at (fracX, fracY) of the natural image to appear where the mouse is.
      // Natural image center is at board center when pan=0.
      // The clicked point in natural coords relative to image center:
      const natOffsetX = (fracX - 0.5) * img.naturalWidth;
      const natOffsetY = (fracY - 0.5) * img.naturalHeight;

      // We need translate so that point ends up at (clickX, clickY) in board coords.
      // Board center is at (boardRect.width/2, boardRect.height/2).
      // Without translate, the point is at (boardCenter + natOffset).
      // With translate (panX, panY), it's at (boardCenter + natOffset + panX, ...).
      // We want: boardCenter + natOffset + panX = clickX
      panX = (clickX - boardRect.width / 2) - natOffsetX;
      panY = (clickY - boardRect.height / 2) - natOffsetY;

      clampPan();
      isZoomPanMode = true;
      board.classList.add('zoom-pan-mode');
      updateImageTransform();
    }

    // Clamp pan so the image doesn't scroll past its edges.
    function clampPan() {
      const boardRect = board.getBoundingClientRect();
      const maxPanX = Math.max(0, (img.naturalWidth - boardRect.width) / 2);
      const maxPanY = Math.max(0, (img.naturalHeight - boardRect.height) / 2);
      panX = Math.max(-maxPanX, Math.min(maxPanX, panX));
      panY = Math.max(-maxPanY, Math.min(maxPanY, panY));
    }

    function updateImageTransform() {
      if (isZoomPanMode) {
        img.style.transform = `translate(${panX}px, ${panY}px)`;
      } else {
        img.style.transform = '';
      }
    }

    // --- Event handlers ---

    function handleBoardMouseDown(e) {
      if (!hasLoadedDiagram) return;
      if (e.button !== 0) return; // left button only

      if (!isZoomPanMode) {
        // In fit mode: only respond if image is larger than viewport
        if (!isImageMinified()) return;
        // Enter zoom-pan mode on mouseup if it's a clean click (handled below)
      }

      // Record drag start
      isDragging = true;
      dragStartMouseX = e.clientX;
      dragStartMouseY = e.clientY;
      dragStartPanX = panX;
      dragStartPanY = panY;

      if (isZoomPanMode) {
        board.classList.add('dragging');
      }

      e.preventDefault();
    }

    function handleMouseMove(e) {
      if (!isDragging) return;
      if (!isZoomPanMode) return; // don't drag in fit mode

      const dx = e.clientX - dragStartMouseX;
      const dy = e.clientY - dragStartMouseY;
      panX = dragStartPanX + dx;
      panY = dragStartPanY + dy;
      clampPan();
      updateImageTransform();
    }

    function handleMouseUp(e) {
      if (!isDragging) return;
      isDragging = false;
      board.classList.remove('dragging');

      const dx = e.clientX - dragStartMouseX;
      const dy = e.clientY - dragStartMouseY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < CLICK_THRESHOLD) {
        // This was a click, not a drag
        if (isZoomPanMode) {
          resetZoomPan();
        } else if (isImageMinified()) {
          const boardRect = board.getBoundingClientRect();
          enterZoomPanMode(e.clientX - boardRect.left, e.clientY - boardRect.top);
        }
      }
    }

    board.addEventListener('mousedown', handleBoardMouseDown);
    document.addEventListener('mousemove', handleMouseMove);
    document.addEventListener('mouseup', handleMouseUp);

    function wsPort() {
      const p = parseInt(location.port || "0", 10);
      return (p > 0) ? String(p + 1) : "8765";
    }

    function connect() {
      const host = location.hostname || "127.0.0.1";
      const wsUrl = "ws://" + host + ":" + wsPort();
      const ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        setStatus("ok", "Connected");
        ws.send(JSON.stringify({type: "refresh"}));
      };

      ws.onmessage = e => {
        try {
          const data = JSON.parse(e.data);
          if (data.type === "update" && data.url) {
            // Don't set hasLoadedDiagram here - only in img.onload to avoid race
            pendingImageLoad = true;
            setStatus("warn", hasLoadedDiagram ? "Reloading..." : "Loading...");
            img.style.opacity = 0;
            resetZoomPan();
            if (data.filename) {
              window.currentFilename = data.filename;
              requestAnimationFrame(updateFilenameDisplay);
            }
            if (data.timestamp) {
              timestampEl.textContent = "Updated: " + data.timestamp;
              timestampEl.title = "Last update time";
            }
            if (data.url) {
              serverUrlEl.textContent = data.url.length > MAX_URL_DISPLAY ? data.url.substring(0, MAX_URL_DISPLAY) + "..." : data.url;
              serverUrlEl.href = data.url;
              serverUrlEl.title = "Click to open PlantUML diagram";
              serverUrlEl.style.display = "block";
            }
            ph.style.display = "none";
            img.src = data.url;
          } else if (data.type === "status") {
            // Handle server state messages
            if (data.state === "ready" && !pendingImageLoad) {
              setStatus("ok", hasLoadedDiagram ? "Live" : "Connected");
              // Reset placeholder to default message when ready
              ph.innerHTML = "Ready for a diagram.<br>Save a PlantUML file in Neovim to view it here.";
            } else if (data.state === "docker_unavailable") {
              setStatus("warn", "Docker not running");
              // Show helpful message about Docker
              if (!hasLoadedDiagram) {
                ph.innerHTML = data.message || "Docker daemon is not running.<br>Start Docker to enable local rendering.";
                ph.style.display = "block";
              }
            } else if (data.state === "docker_pending") {
              setStatus("warn", "Starting Docker...");
            } else if (data.state === "starting") {
              setStatus("warn", "Starting...");
            }
            // If server says it has no diagram yet, show placeholder
            if (data.has_diagram === false && !hasLoadedDiagram && data.state !== "docker_unavailable") {
              ph.style.display = "block";
            }
          } else if (data.type === "docker_status") {
            // Handle Docker status messages
            if (data.status) {
              const statusKind = data.error ? "err" : "warn";
              setStatus(statusKind, data.status);

              // Clear any existing timeout before setting a new one
              if (dockerStatusTimeoutId) {
                clearTimeout(dockerStatusTimeoutId);
                dockerStatusTimeoutId = null;
              }

              // If Docker operation completed successfully, transition to Live after a brief delay
              if (data.completed && !data.error) {
                dockerStatusTimeoutId = setTimeout(() => {
                  dockerStatusTimeoutId = null;
                  if (!pendingImageLoad) {
                    setStatus("ok", hasLoadedDiagram ? "Live" : "Connected");
                  }
                }, DOCKER_STATUS_DELAY);
              }
            }
          }
        } catch (err) {
          console.error(err);
        }
      };

      ws.onclose = () => {
        setStatus("err", "Reconnecting...");
        setTimeout(connect, RECONNECT_DELAY);
      };
      ws.onerror = () => setStatus("err", "Error");
    }

    img.onload = () => {
      img.style.opacity = 1;
      pendingImageLoad = false;
      // Only place where hasLoadedDiagram is set to true - prevents race condition
      if (!hasLoadedDiagram) {
        hasLoadedDiagram = true;
        board.classList.add('has-diagram');
      }
      setStatus("ok", "Live");
    };

    img.onerror = () => {
      pendingImageLoad = false;
      setStatus("err", "Load failed");
    };

    setStatus("warn", "Connecting...");
    connect();
  </script>
</body>

</html>
