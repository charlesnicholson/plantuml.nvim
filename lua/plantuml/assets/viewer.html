<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>PlantUML Viewer</title>
  <style>
    :root {
      --bg: #0b0c0e;
      --fg: #d7d7db;
      --muted: #8b8d94;
      --pill-bg: #1a1b1e;
      --ok: #2ea043;
      --warn: #b8821f;
      --err: #be3431;
      --panel: #0f1013;
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--fg);
      font: 14px/1.45 -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
      display: flex;
      flex-direction: column;
    }

    .top {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: .5rem .75rem;
      border-bottom: 1px solid #111318;
      background: var(--panel);
    }

    .status-section {
      display: flex;
      align-items: center;
    }

    .filename-section {
      display: flex;
      align-items: center;
      justify-content: center;
      flex: 1;
      margin: 0 1rem;
      min-width: 0;
    }

    .info-section {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: .25rem;
    }

    .dot {
      width: .5rem;
      height: .5rem;
      border-radius: 999px;
      display: inline-block;
      vertical-align: middle;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: .35rem;
      padding: .15rem .45rem;
      border-radius: 999px;
      background: var(--pill-bg);
      color: var(--muted);
      font-size: .75rem;
      font-weight: 500;
    }

    .pill .dot {
      background: var(--warn);
    }

    .pill.ok .dot {
      background: var(--ok);
    }

    .pill.err .dot {
      background: var(--err);
    }

    .pill.warn .dot {
      background: var(--warn);
    }

    .file,
    .server-link,
    .timestamp {
      white-space: nowrap;
      overflow: hidden;
    }

    .file {
      color: var(--fg);
      font-weight: 600;
      font-size: 1rem;
      text-align: center;
      max-width: 100%;
    }

    .server-link,
    .timestamp {
      color: var(--muted);
      font-size: .75rem;
      text-overflow: ellipsis;
      text-align: right;
    }

    .server-link {
      text-decoration: none;
      display: block;
    }

    .server-link:hover {
      color: var(--fg);
      text-decoration: underline;
    }

    .wrap {
      flex: 1;
      min-height: 0;
      padding: 0.75rem;
    }

    .board {
      position: relative;
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 8px;
      background: #0c0d10;
      outline: 1px solid #111318;
      overflow: hidden;
    }

    #img {
      display: none;
      opacity: 0;
      transition: opacity .2s ease-in-out;
      width: auto;
      height: auto;
      max-width: 100%;
      max-height: 100%;
      cursor: pointer;
    }

    .board.zoom-pan-mode {
      cursor: move;
    }

    .board.zoom-pan-mode #img {
      max-width: none;
      max-height: none;
      cursor: move;
      transition: transform 0.1s ease-out;
    }

    .board.has-diagram #img {
      display: block;
    }

    #ph {
      color: var(--muted);
      font-size: .9rem;
      text-align: center;
    }
  </style>
</head>

<body>
  <div class="top">
    <div class="status-section">
      <span id="status" class="pill">
        <span class="dot"></span>
        <span id="status-text">connecting</span>
      </span>
    </div>
    <div class="filename-section">
      <span class="file" id="file" title="filename"></span>
    </div>
    <div class="info-section">
      <a class="server-link" id="server-url" href="#" target="_blank" title="PlantUML server URL"></a>
      <span class="timestamp" id="timestamp"></span>
    </div>
  </div>
  <div class="wrap">
    <div class="board" id="board">
      <img id="img" alt="PlantUML diagram">
      <p id="ph">Ready for a diagram.<br>Save a PlantUML file in Neovim to view it here.</p>
    </div>
  </div>
  <script>
    const ZOOM_SCALE = 0.8;
    const FALLBACK_WIDTH = 200;
    const MAX_URL_DISPLAY = 70;
    const DOCKER_STATUS_DELAY = 1500;
    const RECONNECT_DELAY = 1000;

    const statusEl = document.getElementById("status");
    const statusText = document.getElementById("status-text");
    const fileEl = document.getElementById("file");
    const ph = document.getElementById("ph");
    const timestampEl = document.getElementById("timestamp");
    const serverUrlEl = document.getElementById("server-url");
    const img = document.getElementById("img");
    const board = document.getElementById("board");

    // State tracking - hasLoadedDiagram only set in img.onload to avoid race
    let hasLoadedDiagram = false;
    let pendingImageLoad = false;
    let dockerStatusTimeoutId = null;
    window.currentFilename = "";

    let isZoomPanMode = false;
    let panX = 0.5; // 0 = show left edge, 0.5 = center, 1 = show right edge
    let panY = 0.5;

    function setStatus(kind, text) {
      statusEl.className = 'pill';
      if (kind) statusEl.classList.add(kind);
      statusText.textContent = text;
    }

    function truncateFilename(fullPath, maxWidth) {
      if (!fullPath) return '';
      const canvas = document.createElement('canvas');
      const ctx = canvas.getContext('2d');
      ctx.font = getComputedStyle(fileEl).font;

      if (ctx.measureText(fullPath).width <= maxWidth) {
        return fullPath;
      }

      const lastSlashIndex = fullPath.lastIndexOf('/');
      if (lastSlashIndex === -1) {
        return fullPath;
      }

      const filename = fullPath.substring(lastSlashIndex + 1);

      if (ctx.measureText(filename).width > maxWidth) {
        return filename;
      }

      const pathParts = fullPath.split('/');
      let bestResult = filename;

      for (let startIndex = pathParts.length - 2; startIndex >= 1; startIndex--) {
        const remainingParts = pathParts.slice(startIndex);
        const candidate = '...' + '/' + remainingParts.join('/');

        if (ctx.measureText(candidate).width <= maxWidth) {
          bestResult = candidate;
        }
      }

      return bestResult;
    }

    window.truncateFilename = truncateFilename;

    function updateFilenameDisplay() {
      if (window.currentFilename) {
        const filenameSection = document.querySelector('.filename-section');
        let maxWidth = filenameSection.getBoundingClientRect().width - 20;

        if (maxWidth <= 0) {
          maxWidth = Math.max(FALLBACK_WIDTH, window.innerWidth * 0.5);
        }

        const truncatedFilename = truncateFilename(window.currentFilename, maxWidth);
        fileEl.textContent = truncatedFilename;
        fileEl.title = window.currentFilename;
      }
    }

    window.truncateFilename = truncateFilename;
    window.updateFilenameDisplay = updateFilenameDisplay;
    window.addEventListener('resize', () => requestAnimationFrame(updateFilenameDisplay));

    function isImageMinified() {
      if (!img.naturalWidth || !img.naturalHeight) return false;
      const boardRect = board.getBoundingClientRect();
      const availableWidth = boardRect.width;
      const availableHeight = boardRect.height;

      return img.naturalWidth > availableWidth || img.naturalHeight > availableHeight;
    }

    function resetZoomPan() {
      isZoomPanMode = false;
      panX = 0.5;
      panY = 0.5;
      board.classList.remove('zoom-pan-mode');
      updateImageTransform();
    }

    function enterZoomPanMode() {
      isZoomPanMode = true;
      board.classList.add('zoom-pan-mode');
      updateImageTransform();
    }

    function updateImageTransform() {
      if (isZoomPanMode) {
        const boardRect = board.getBoundingClientRect();

        // Zoomed image dimensions (80% of natural size)
        const zoomedWidth = img.naturalWidth * ZOOM_SCALE;
        const zoomedHeight = img.naturalHeight * ZOOM_SCALE;

        // How much the zoomed image exceeds the viewport
        const excessWidth = zoomedWidth - boardRect.width;
        const excessHeight = zoomedHeight - boardRect.height;

        // Calculate translation to show the desired portion
        // panX: 0 = left edge, 0.5 = center, 1 = right edge
        // With transform-origin: center, the image center starts at board center
        // translateX > 0 moves image right (shows left side)
        // translateX < 0 moves image left (shows right side)
        let translateX = 0;
        let translateY = 0;

        if (excessWidth > 0) {
          translateX = excessWidth * (0.5 - panX);
        }
        // If excessWidth <= 0, image fits horizontally, keep centered

        if (excessHeight > 0) {
          translateY = excessHeight * (0.5 - panY);
        }
        // If excessHeight <= 0, image fits vertically, keep centered

        img.style.transformOrigin = 'center';
        img.style.transform = `translate(${translateX}px, ${translateY}px) scale(${ZOOM_SCALE})`;
      } else {
        img.style.transform = '';
        img.style.transformOrigin = '';
      }
    }

    function updatePanFromMouseEvent(e) {
      const boardRect = board.getBoundingClientRect();
      // Map mouse position to 0-1 range
      // Mouse at left edge → panX = 0 → show left of image
      // Mouse at right edge → panX = 1 → show right of image
      panX = (e.clientX - boardRect.left) / boardRect.width;
      panY = (e.clientY - boardRect.top) / boardRect.height;
      // Clamp to valid range
      panX = Math.max(0, Math.min(1, panX));
      panY = Math.max(0, Math.min(1, panY));
    }

    function handleImageClick(e) {
      if (!hasLoadedDiagram) return;

      if (isImageMinified()) {
        if (isZoomPanMode) {
          resetZoomPan();
        } else {
          updatePanFromMouseEvent(e);
          enterZoomPanMode();
        }
      }
    }

    function handleMouseMove(e) {
      if (!isZoomPanMode) return;
      updatePanFromMouseEvent(e);
      updateImageTransform();
    }

    function handleMouseDown(e) {
      if (!isZoomPanMode) return;
      e.preventDefault();
    }

    img.addEventListener('click', handleImageClick);
    board.addEventListener('mousemove', handleMouseMove);
    board.addEventListener('mousedown', handleMouseDown);

    function wsPort() {
      const p = parseInt(location.port || "0", 10);
      return (p > 0) ? String(p + 1) : "8765";
    }

    function connect() {
      const host = location.hostname || "127.0.0.1";
      const wsUrl = "ws://" + host + ":" + wsPort();
      const ws = new WebSocket(wsUrl);

      ws.onopen = () => {
        setStatus("ok", "Live");
        ws.send(JSON.stringify({type: "refresh"}));
      };

      ws.onmessage = e => {
        try {
          const data = JSON.parse(e.data);
          if (data.type === "update" && data.url) {
            // Don't set hasLoadedDiagram here - only in img.onload to avoid race
            pendingImageLoad = true;
            setStatus("warn", "Reloading...");
            img.style.opacity = 0;
            resetZoomPan();
            if (data.filename) {
              window.currentFilename = data.filename;
              requestAnimationFrame(updateFilenameDisplay);
            }
            if (data.timestamp) {
              timestampEl.textContent = "Updated: " + data.timestamp;
              timestampEl.title = "Last update time";
            }
            if (data.url) {
              serverUrlEl.textContent = data.url.length > MAX_URL_DISPLAY ? data.url.substring(0, MAX_URL_DISPLAY) + "..." : data.url;
              serverUrlEl.href = data.url;
              serverUrlEl.title = "Click to open PlantUML diagram";
              serverUrlEl.style.display = "block";
            }
            ph.style.display = "none";
            img.src = data.url;
          } else if (data.type === "status") {
            // Handle server state messages
            if (data.state === "ready" && !pendingImageLoad) {
              setStatus("ok", "Live");
              // Reset placeholder to default message when ready
              ph.innerHTML = "Ready for a diagram.<br>Save a PlantUML file in Neovim to view it here.";
            } else if (data.state === "docker_unavailable") {
              setStatus("warn", "Docker not running");
              // Show helpful message about Docker
              if (!hasLoadedDiagram) {
                ph.innerHTML = data.message || "Docker daemon is not running.<br>Start Docker to enable local rendering.";
                ph.style.display = "block";
              }
            } else if (data.state === "docker_pending") {
              setStatus("warn", "Starting Docker...");
            } else if (data.state === "starting") {
              setStatus("warn", "Starting...");
            }
            // If server says it has no diagram yet, show placeholder
            if (data.has_diagram === false && !hasLoadedDiagram && data.state !== "docker_unavailable") {
              ph.style.display = "block";
            }
          } else if (data.type === "docker_status") {
            // Handle Docker status messages
            if (data.status) {
              const statusKind = data.error ? "err" : "warn";
              setStatus(statusKind, data.status);

              // Clear any existing timeout before setting a new one
              if (dockerStatusTimeoutId) {
                clearTimeout(dockerStatusTimeoutId);
                dockerStatusTimeoutId = null;
              }

              // If Docker operation completed successfully, transition to Live after a brief delay
              if (data.completed && !data.error) {
                dockerStatusTimeoutId = setTimeout(() => {
                  dockerStatusTimeoutId = null;
                  if (!pendingImageLoad) {
                    setStatus("ok", "Live");
                  }
                }, DOCKER_STATUS_DELAY);
              }
            }
          }
        } catch (err) {
          console.error(err);
        }
      };

      ws.onclose = () => {
        setStatus("err", "Reconnecting...");
        setTimeout(connect, RECONNECT_DELAY);
      };
      ws.onerror = () => setStatus("err", "Error");
    }

    img.onload = () => {
      img.style.opacity = 1;
      pendingImageLoad = false;
      // Only place where hasLoadedDiagram is set to true - prevents race condition
      if (!hasLoadedDiagram) {
        hasLoadedDiagram = true;
        board.classList.add('has-diagram');
      }
      setStatus("ok", "Live");
    };

    img.onerror = () => {
      pendingImageLoad = false;
      setStatus("err", "Load failed");
    };

    setStatus("warn", "Connecting...");
    connect();
  </script>
</body>

</html>
